[👉查看網頁 Color Mapper](https://color-mapper.vercel.app/)


## Semantic Color Mapper (顏色語感對應研究)

> 協助我們建立人類對顏色的感知地圖。

這是一個實驗專案，旨在探索 **「數學上的顏色數值」**(OKLch) 與 **「人類語言描述」**(Semantic Name)之間的關聯。
透過收集使用者的命名數據，我們試圖回答一個問題：**「在人類眼中，黃色是在哪裡變成了橘色？深藍色又是在哪裡變成了黑色？」**


### 核心功能

- **🎯 隨機色彩測驗**：系統會在 OKLch 色彩空間中隨機生成顏色，邀請使用者進行命名。
- **🤖 AI 智慧審核**：整合 **Google Gemini AI**，即時分析使用者的命名。
  - 自動過濾亂碼與無意義詞彙。
  - 識別具創意或「有味道」的命名（如：屎色）並給予幽默回饋。
  - 防止明顯的視覺矛盾（如把紅色說成綠色）。
- **📊 即時數據視覺化**：使用 **D3.js** 繪製色彩分佈圖，即時顯示眾人對特定色相的定義範圍。
- **☁️ 雲端同步**：結合 **Firebase Realtime Database**，所有數據即時上傳並同步給所有用戶。
- **🌓 現代化介面**：支援深色/淺色模式切換，專注於色彩體驗的 UI 設計。


### 技術棧 (Tech Stack)

- **Frontend**: React, TypeScript, Vite
- **Styling**: Tailwind CSS, clsx
- **Visualization**: D3.js (d3-delaunay)
- **AI Integration**: Google Generative AI SDK (Gemini 1.5 Flash)
- **Backend / Database**: Firebase Realtime Database
- **Deployment**: Vercel

----

### 更新記錄（Changelog）



- `2025/12/??（？）`答題後有回饋了
  - 答題後，會有AI點評回饋（於右下角 toast 板子彈出），增加作答後的回饋感
  - 答太爛是會被婉拒收錄的
- `2025/12/??（？）`
  - 將答題過的資料，儲存在網頁的 localStorage，同一人可以看到自己先前答題過的記錄（先前頁面重整資料就不見）
  - 此時還沒能讓世界各地的人共享資料
- `2025/12/05（五）`
  - AI（Gemini）判定太嚴苛，導致有些有趣的名字會不收錄
  - 放寬標準為只防止類似「紅色故意說綠色」、「白色說黑色」等這種一看就不合理的答案
- `2025/12/04（四）`開始製作
  - 開始透過 Google AI Studio 的 Build 製作顏色語感表，想透過共識決議，做成網頁集結大家力量完成顏色的命名
  - 製作了 題目顏色隨機生成考卷，尋問使用者這是什麼顏色，答題後會有AI（Gemini）判定回答該不該被收錄
  - 製作了 voronoi 分布圖表，利用空間分割算法，得知那些區域的顏色大眾都會如何稱呼
  - 此時網頁還沒對外開放






- `2025/12/12（五）`
  - AI定奪顏色的命名更人性化了。屎尿屁之類的命名，如果合理也是會收錄。如果只是在亂輸入一些廢話會被成功擋下來。

- `2025/12/18（四）`
  - 成功發布於網路，變成了網站
  - 真的串接了後台（Firebase），可以世界各地的人共享資料了
  - 真的串接了AI（Gemini），可以幫忙判定回答有沒有效了

- `2025/12/19（五）`
  - 修正圖表，「極限飽和度的虛線」於低亮度時會有不自然的凸出，

- `2025/12/22（一）`

- `2025/12/23（二）`
  - 讓前綴按鈕變成一排，過長可左右滑動，而非過長換行（wrap）。目的為減少空間浪費，避免鍵盤升起時都看不到題目顏色。
  - 點擊輸入框/前綴按鈕，要讓鍵盤升起，暗示使用者繼續輸入，解決了使用者選了前綴字就想送出的毛病
  - 手機版升起鍵盤後，讓「輸入框與送出鈕」正確在剩餘畫面露出，不被鍵盤遮擋
  - 承上，解決了捲動不順暢的問題（手機瀏覽器有太多種意外）
  - 作法：
    - 初次點擊時，要抓視窗的高度變化兩次，第一次是中斷安卓預設捲動規則（預設捲太高了），且安卓反應真的慢半拍需要第二次抓定位（iOS第一次就會開始捲動）。第二次是重新抓定位（時間也不能太早，要大於iOS鍵盤升起來的時間，才不會讓iOS有破綻看到「捲停捲停」兩次）
    - 再次點擊時，因瀏覽器已經得知了鍵盤升起後的剩餘高度，就不用再抓視窗的高度變化兩次了，改為一次就好（但時間也不能太即時，因為安卓會慢半拍）
